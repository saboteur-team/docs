{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Saboteur Team Wiki Please join our Discord for more information","title":"Home"},{"location":"#welcome-to-saboteur-team-wiki","text":"Please join our Discord for more information","title":"Welcome to Saboteur Team Wiki"},{"location":"game/","text":"Game This wiki is focusing on the PC version of the game, so every file, offset, type, etc... is for the PC version, if not otherwise stated.","title":"Index"},{"location":"game/#game","text":"This wiki is focusing on the PC version of the game, so every file, offset, type, etc... is for the PC version, if not otherwise stated.","title":"Game"},{"location":"game/crc/","text":"Crc The game is using a modified FNV32-a alrogithm to calculate Crc values from strings and uses them for identification for most of the static assets and ingame stuff. As the FNV32 is a hashing alrogithm, we are unable to get the original string back from the hash, but bruteforcing and targeted guessing can be used to find more values. This hash implementation is case-insensitive, so the hashes of \"TEST\" and \"test\" are the same. C# algorithm: public const uint FNV32Offset = 0x811C9DC5u; public const uint FNV32Prime = 0x1000193u; public static uint FNV32string(string source, int maxLen = -1) { if (string.IsNullOrEmpty(source)) return 0; var bytes = Encoding.UTF8.GetBytes(source); var hash = FNV32Offset; for (var i = 0; i < bytes.Length && (maxLen == -1 || i < maxLen); ++i) hash = FNV32Prime * (hash ^ (bytes[i] | 0x20u)); return (hash ^ 0x2Au) * FNV32Prime; } The SabTool tool can calculate, bruteforce and look up hashes (from a hash to string lookup file, that was manually created for this purpose).","title":"Crc"},{"location":"game/crc/#crc","text":"The game is using a modified FNV32-a alrogithm to calculate Crc values from strings and uses them for identification for most of the static assets and ingame stuff. As the FNV32 is a hashing alrogithm, we are unable to get the original string back from the hash, but bruteforcing and targeted guessing can be used to find more values. This hash implementation is case-insensitive, so the hashes of \"TEST\" and \"test\" are the same. C# algorithm: public const uint FNV32Offset = 0x811C9DC5u; public const uint FNV32Prime = 0x1000193u; public static uint FNV32string(string source, int maxLen = -1) { if (string.IsNullOrEmpty(source)) return 0; var bytes = Encoding.UTF8.GetBytes(source); var hash = FNV32Offset; for (var i = 0; i < bytes.Length && (maxLen == -1 || i < maxLen); ++i) hash = FNV32Prime * (hash ^ (bytes[i] | 0x20u)); return (hash ^ 0x2Au) * FNV32Prime; } The SabTool tool can calculate, bruteforce and look up hashes (from a hash to string lookup file, that was manually created for this purpose).","title":"Crc"},{"location":"game/filesystem/","text":"Filesystem Main Name Description / Name Description AnimText/ Unknown text files for animations Cinematics/ComplexAnimations/ComplexAnimations.cxa Cinematics/Dialog/[language]/GameText.dlg Game dialog texts for the given language DLC/01/ The first DLC's root folder FaceFX/ Face effects? logs/ Log files Recordings/ Voice over recordings Sound/ WWise soundbank packs ai.ini Animations.pack data01.bin France.ambush France.cinsplines France.defen France.freeplay France.GpsGraph France.hei France.hqpoints France.materials Mesh material definitions France.paths France.railway France.rndnodes France.spore France.trigs France.waterctrl France.waterflow France_FSM.info France_FST.info InputTemplates.txt LuaScripts.luap Compiled & packaged lua scripts ModelInfo.txt particle.pack particle.tuv Saboteur.exe The game's executable SoundBanks.ini startlocs.ini tuner.txt water_planes.ini /Bink/ Name Description 115_CinA_Cheat.bik Video of Dierker cheating in the race 121_CinA_Qestion.bik Video of Dierker questioning Sean 127_CinA_Intro.bik Intro video showing the Belle 201_CinA_3Months.bik Nazis occupying Paris cutscene and 3 months later text 217_CinB_Box.bik Sean opening the box in the cemetery cutscene 221_CinA_BlimpCrash.bik Zeppelin crash cutscene 333_CinA_RaceBoom.bik Explosion at the Eiffel Tower after the race 407_cinb_flashback.bik Sean's questioning flashback 408_CinB_DoppBoom.bik Doppelsieg factory explosion cutscene Ambient_FP.bik Introduction video for Santos' shops Sab_Palceholder.bik Placeholder movie stating: \"TEMP MOVIE\" saboteur.bik Loading video for the main menu saboteur_de.bik Loading video for the German version main menu /France/ Name Description BelleStart0.kiloPack Unknown megapack loosefiles_BinPC.pack PC loosefiles Mega0.megapack Data container megapack Mega1.megapack Data container megapack Mega2.megapack Data container megapack Start_German0.kiloPack German starting data megapack Start0.kiloPack Starting data megapack /Global/ Name Description Dynamic0.megapack Dynamic global megapack Palettes0.megapack Palettees global megapack DLC DLC Root","title":"Filesystem"},{"location":"game/filesystem/#filesystem","text":"","title":"Filesystem"},{"location":"game/filesystem/#main","text":"Name Description","title":"Main"},{"location":"game/filesystem/#_1","text":"Name Description AnimText/ Unknown text files for animations Cinematics/ComplexAnimations/ComplexAnimations.cxa Cinematics/Dialog/[language]/GameText.dlg Game dialog texts for the given language DLC/01/ The first DLC's root folder FaceFX/ Face effects? logs/ Log files Recordings/ Voice over recordings Sound/ WWise soundbank packs ai.ini Animations.pack data01.bin France.ambush France.cinsplines France.defen France.freeplay France.GpsGraph France.hei France.hqpoints France.materials Mesh material definitions France.paths France.railway France.rndnodes France.spore France.trigs France.waterctrl France.waterflow France_FSM.info France_FST.info InputTemplates.txt LuaScripts.luap Compiled & packaged lua scripts ModelInfo.txt particle.pack particle.tuv Saboteur.exe The game's executable SoundBanks.ini startlocs.ini tuner.txt water_planes.ini","title":"/"},{"location":"game/filesystem/#bink","text":"Name Description 115_CinA_Cheat.bik Video of Dierker cheating in the race 121_CinA_Qestion.bik Video of Dierker questioning Sean 127_CinA_Intro.bik Intro video showing the Belle 201_CinA_3Months.bik Nazis occupying Paris cutscene and 3 months later text 217_CinB_Box.bik Sean opening the box in the cemetery cutscene 221_CinA_BlimpCrash.bik Zeppelin crash cutscene 333_CinA_RaceBoom.bik Explosion at the Eiffel Tower after the race 407_cinb_flashback.bik Sean's questioning flashback 408_CinB_DoppBoom.bik Doppelsieg factory explosion cutscene Ambient_FP.bik Introduction video for Santos' shops Sab_Palceholder.bik Placeholder movie stating: \"TEMP MOVIE\" saboteur.bik Loading video for the main menu saboteur_de.bik Loading video for the German version main menu","title":"/Bink/"},{"location":"game/filesystem/#france","text":"Name Description BelleStart0.kiloPack Unknown megapack loosefiles_BinPC.pack PC loosefiles Mega0.megapack Data container megapack Mega1.megapack Data container megapack Mega2.megapack Data container megapack Start_German0.kiloPack German starting data megapack Start0.kiloPack Starting data megapack","title":"/France/"},{"location":"game/filesystem/#global","text":"Name Description Dynamic0.megapack Dynamic global megapack Palettes0.megapack Palettees global megapack","title":"/Global/"},{"location":"game/filesystem/#dlc","text":"","title":"DLC"},{"location":"game/filesystem/#dlc-root","text":"","title":"DLC Root"},{"location":"game/versions/","text":"Versions For PC, there is several versions of game (executable) available: Retail Release - v1.0.0.1 - contains SecuROM DRM Skidrow Crack for Retail Release - v1.0.0.1 - removes SecuROM DRM from the Retail executable and also extracts some files which are bundled into the .exe Origin Version - ??? GOG Version - This version is interesting, because it's Retail Release version, with Skidrow crack, and with binary patch (who someone post into the reviews on GOG) to support 4+ core CPUs. So basically this release is using cracked exe. This also means that offsets for GOG Version are same as for Skidrow crack.","title":"Versions"},{"location":"game/versions/#versions","text":"For PC, there is several versions of game (executable) available: Retail Release - v1.0.0.1 - contains SecuROM DRM Skidrow Crack for Retail Release - v1.0.0.1 - removes SecuROM DRM from the Retail executable and also extracts some files which are bundled into the .exe Origin Version - ??? GOG Version - This version is interesting, because it's Retail Release version, with Skidrow crack, and with binary patch (who someone post into the reviews on GOG) to support 4+ core CPUs. So basically this release is using cracked exe. This also means that offsets for GOG Version are same as for Skidrow crack.","title":"Versions"},{"location":"game/client/","text":"","title":"Index"},{"location":"game/client/random_offsets/","text":"Offsets NOTE: Needs to be cleaned All offsets are for GOG and for SKIDROW crack gamiee: 0x754040 - probably function to define functions in native Lua functions 0x753B20 - require lua func 0x9CCF30 - WSLoadDisplayManager::Update_Display - Renders main menu 0x429700 - WndProc 0x120F461 - Global Variable, bool, 1 => window is focused, 0 => not focused 0x00429785 - This sets focus variable to zero, nop it to not open settings when window is unfocused Dan: // Camera mode settings: // 00000000: Normal (Follows player) // 00000001: Scenic (Controlled programmatically, e.g. scenic view animation & main menu fixed location) // 00000002: Static (Stationary, does not follow player) *(DWORD *)(*(DWORD *)0x1321b74 + 0x2c) = cameraMode; Igoh: all together should remove all the peds on the map Unprotect(0x9cccac, 1); *(BYTE *)0x9cccac = 0xeb; Unprotect(0x461eb1, 1); *(BYTE *)0x461eb1 = 0xeb; // \"aispawner\" Unprotect(0x6f5d6c, 1); *(BYTE *)0x6f5d6c = 0xeb; // disable res spawner Unprotect(0x6f5de9, 1); *(BYTE *)0x6f5de9 = 0xeb; // disable nazi spawner Unprotect(0x907816, 6); *(DWORD *)0x907816 = 393705; *(BYTE *)(0x907816 + 5) = 0x90; // disable patrol spawner Unprotect(0x9909D3, 2); *(__int16 *)0x9909D3 = 12523; Unprotect(0x990AC5, 2); *(__int16 *)0x990AC5 = 12779; Unprotect(0x99099B, 2); *(__int16 *)0x99099B = 14059; Unprotect(0x99096f, 2); *(__int16 *)0x99096f = 10987; // Disposables_MaxMale | Disposables_MaxFemale | Disposables_MaxVendor | Disposables_NaziPadding Unprotect(0x81433A, 2); *(unsigned __int16 *)0x81433A = 32491; Unprotect(0x8143B1, 4); *(DWORD *)0x8143B1 = 0xff6914; // Remove spores Unprotect(0x49574f, 6); memcpy((LPVOID)0x49574F, (void *)\"\\xe9\\x8f\\x08\\x00\\x00\\x90\", 6); Unprotect(0x461AC5, 1); *(BYTE *)0x461AC5 = 0xeb; ped pool DWORD *pedPool = *(DWORD **)(*(DWORD *)0x14a9ce0 + 0x34); for (; pedPool; pedPool = *(DWORD**)pedPool) { DWORD _ped = pedPool[2]; if (_ped == NULL) break; DWORD _baseBegin = *(DWORD *)(_ped + 0x950 + 0x150); // probably a matrix or some shit DWORD _baseTwo = *(DWORD *)(_baseBegin + 0x30); DWORD _baseT = *(DWORD *)(_baseTwo + 0x18); DWORD _baseR = _baseT + 0x30; float x = *(float *)(_baseR + 0); float y = *(float *)(_baseR + 4); float z = *(float *)(_baseR + 8); float rot = *(float *)(*(DWORD *)(_ped + 0x10CC) + 0x704); pChatWindow->AddDebugMessage(\"Ped: 0x%p (bb: 0x%p, b: 0x%p), pos: %f %f %f %f\", _ped, _baseBegin, _baseR, x, y, z, rot); } void CGame::ShowMinimap(BYTE bToggle) { *(BYTE *)(*(DWORD *)(*(DWORD *)0x14a9b14 + 0x8c) + 0x35) = bToggle; } unsigned __int16 CGame::GetTime() { float actualTime = *(float *)(*(DWORD *)0x14941EC + 0x18); BYTE result[2] = { 0, 0 }; int bMinutes = ((int)actualTime % 3600) / 60; int bHours = (int)actualTime / 3600; result[0] = bHours; result[1] = bMinutes; return *(unsigned __int16 *)result; } void CGame::SetTime(int bHour, int bMinute) { if(bHour >= 24) bHour = 23; if(bMinute > 59) bMinute = 59; float time = bMinute * 60.0 + bHour * 3600.0; *(float *)(*(DWORD *)0x14941EC + 0x18) = time; *(float *)(*(DWORD *)0x14941EC + 0x40) = time; } void CGame::SetWTFMode(BOOL bToggle) { *(DWORD *)(*(DWORD *)0x147dcac + 0x84) = 2863268097; *(DWORD *)(*(DWORD *)0x147dcac + 0x9c) = 2863311361; *(DWORD *)(*(DWORD *)0x147dcac + 0xac) = 1084227584; *(DWORD *)(*(DWORD *)0x147dcac + 0x90) = bToggle ? 2863311360 : 2863311361; } current HP: *(float *)(*(DWORD *)0x123f8b8 + 0x3fc) void CGame::FreezeTime(BOOL bToggle) { *(float *)(*(DWORD *)0x14941EC + 0x1c) = bToggle ? 0 : 12; } void CGame::SetCameraMatrix(MATRIX4X4 matPos) { *(__int16 *)0x444F40 = 6379; *(__int16 *)0x004376C0 = 25323; DWORD cameraMatrix = *(DWORD *)0x14aacac + 0xb0; matPos.pad_p = 1.0f; memcpy((LPVOID)cameraMatrix, &matPos, sizeof(MATRIX4X4)); *(__int16 *)0x444F40 = 17547; *(__int16 *)0x004376C0 = -15989; } mainwnd: *(HWND *)0x120F458 is paused vel in menu: *(DWORD *)0x14d6d38 == 0x200; // Disable global suspicion Unprotect(0x11bb674, 1); *(BYTE *)0x11bb674 = 0; Unprotect(0x45DCBD, 1); *(BYTE *)0x45DCBD = 0; // Install OnDeath hook InstallJmpHook(0x5B7DEB, (DWORD)OnDeath); ... DWORD dwJmp = 0; void __declspec(naked) OnDeath() { dwJmp = 0x5B7E8A; printf(\"im in death\"); *(DWORD *)0x111c334 = 1120403456; // prevents calling this func in loop _asm { jmp dwJmp } } // fade in, last argument is float how long it will take to fade the screen DWORD dwColor = 255 | ((255 | ((255 | (255 << 8)) << 8)) << 8); ((void(__fastcall*)(DWORD, DWORD, DWORD, float))0x9bc170)(*(DWORD *)0x14A9B14, 0, dwColor, 0); // sets bird density *(BYTE *)(*(DWORD *)0x12102d0 + 0x67e4) = 254; // togle birds *(BYTE *)(*(DWORD *)0x12102d0 + 0x67e5) = bToggle ? 168 : 160; // toggle mini zep *(BYTE *)(*(DWORD *)0x143d958 + 0xec) = bToggle ? 166 : 160; // sets drunk level *(float *)(*(DWORD *)0x143d02c + 0x28) = fDrunk; // force camera behind player, 167 disables moving camera *(BYTE *)(*(DWORD *)0x1494360 + 0x10c60) = 168; // game speed *(float *)0x14e1c6c = 1000; // death state *(BYTE *)(*(DWORD *)0x123f8b8 + 0xa98) = 0; // disables falling sounds jmp at 0x54EFE1 0x9E8D20 // func which displays stats menu, has all struct offsets listed with names 0x14AADCC - struct pointer #define _pad(x,y) BYTE x[y] typedef struct _STATS { _pad(__pad0a, 0x18); // 000-024 DWORD naziWehrmachtKilled; DWORD naziKrigsmarineSquadKilled; _pad(__pad0b, 0x4); // removed ?? DWORD naziGestapoKilled; DWORD naziSSKilled; DWORD naziTerrorSquadKilled; DWORD naziDoppelziegKilled; _pad(__pad0c, 0x4); // end nazi killed stats DWORD mostNazisKilledInOneLife; _pad(__pad0d, 0x4); DWORD mostNazisKilledAtOnce; DWORD mostNazisKilledWhileDriving; DWORD mostNazisKilledBySuprise; _pad(__pad0e, 0x4); DWORD birdsKilled; DWORD civiliansKilledByPlayer; DWORD civiliansKilledByNazis; DWORD resistanceKilled; DWORD cigarettesSmoked; DWORD totalBombsPlanted; DWORD civiliansSaved; DWORD flamethrowerFuelSpent; _pad(__pad0f, 0x8); // and keeps goin } STATS; // prevents menu open 0 enables it bck *(BYTE *)0x1240545 = 1; *(BYTE *)(*(DWORD *)0x120F5C4 + 0x3fdfd) = 1; // disables load & save buttons in menu // or *(BYTE *)0x7a4346 = 0xeb; // disables for good *(__int16 *)0x5C136B = 16619; // disables quickload from button *(BYTE *)0x4365bc = 0xc3; // disables quicksave from button (disable it after character spawned, otherwise game won't get through start loading)","title":"Random Offsets"},{"location":"game/client/random_offsets/#offsets","text":"NOTE: Needs to be cleaned All offsets are for GOG and for SKIDROW crack gamiee: 0x754040 - probably function to define functions in native Lua functions 0x753B20 - require lua func 0x9CCF30 - WSLoadDisplayManager::Update_Display - Renders main menu 0x429700 - WndProc 0x120F461 - Global Variable, bool, 1 => window is focused, 0 => not focused 0x00429785 - This sets focus variable to zero, nop it to not open settings when window is unfocused Dan: // Camera mode settings: // 00000000: Normal (Follows player) // 00000001: Scenic (Controlled programmatically, e.g. scenic view animation & main menu fixed location) // 00000002: Static (Stationary, does not follow player) *(DWORD *)(*(DWORD *)0x1321b74 + 0x2c) = cameraMode; Igoh: all together should remove all the peds on the map Unprotect(0x9cccac, 1); *(BYTE *)0x9cccac = 0xeb; Unprotect(0x461eb1, 1); *(BYTE *)0x461eb1 = 0xeb; // \"aispawner\" Unprotect(0x6f5d6c, 1); *(BYTE *)0x6f5d6c = 0xeb; // disable res spawner Unprotect(0x6f5de9, 1); *(BYTE *)0x6f5de9 = 0xeb; // disable nazi spawner Unprotect(0x907816, 6); *(DWORD *)0x907816 = 393705; *(BYTE *)(0x907816 + 5) = 0x90; // disable patrol spawner Unprotect(0x9909D3, 2); *(__int16 *)0x9909D3 = 12523; Unprotect(0x990AC5, 2); *(__int16 *)0x990AC5 = 12779; Unprotect(0x99099B, 2); *(__int16 *)0x99099B = 14059; Unprotect(0x99096f, 2); *(__int16 *)0x99096f = 10987; // Disposables_MaxMale | Disposables_MaxFemale | Disposables_MaxVendor | Disposables_NaziPadding Unprotect(0x81433A, 2); *(unsigned __int16 *)0x81433A = 32491; Unprotect(0x8143B1, 4); *(DWORD *)0x8143B1 = 0xff6914; // Remove spores Unprotect(0x49574f, 6); memcpy((LPVOID)0x49574F, (void *)\"\\xe9\\x8f\\x08\\x00\\x00\\x90\", 6); Unprotect(0x461AC5, 1); *(BYTE *)0x461AC5 = 0xeb; ped pool DWORD *pedPool = *(DWORD **)(*(DWORD *)0x14a9ce0 + 0x34); for (; pedPool; pedPool = *(DWORD**)pedPool) { DWORD _ped = pedPool[2]; if (_ped == NULL) break; DWORD _baseBegin = *(DWORD *)(_ped + 0x950 + 0x150); // probably a matrix or some shit DWORD _baseTwo = *(DWORD *)(_baseBegin + 0x30); DWORD _baseT = *(DWORD *)(_baseTwo + 0x18); DWORD _baseR = _baseT + 0x30; float x = *(float *)(_baseR + 0); float y = *(float *)(_baseR + 4); float z = *(float *)(_baseR + 8); float rot = *(float *)(*(DWORD *)(_ped + 0x10CC) + 0x704); pChatWindow->AddDebugMessage(\"Ped: 0x%p (bb: 0x%p, b: 0x%p), pos: %f %f %f %f\", _ped, _baseBegin, _baseR, x, y, z, rot); } void CGame::ShowMinimap(BYTE bToggle) { *(BYTE *)(*(DWORD *)(*(DWORD *)0x14a9b14 + 0x8c) + 0x35) = bToggle; } unsigned __int16 CGame::GetTime() { float actualTime = *(float *)(*(DWORD *)0x14941EC + 0x18); BYTE result[2] = { 0, 0 }; int bMinutes = ((int)actualTime % 3600) / 60; int bHours = (int)actualTime / 3600; result[0] = bHours; result[1] = bMinutes; return *(unsigned __int16 *)result; } void CGame::SetTime(int bHour, int bMinute) { if(bHour >= 24) bHour = 23; if(bMinute > 59) bMinute = 59; float time = bMinute * 60.0 + bHour * 3600.0; *(float *)(*(DWORD *)0x14941EC + 0x18) = time; *(float *)(*(DWORD *)0x14941EC + 0x40) = time; } void CGame::SetWTFMode(BOOL bToggle) { *(DWORD *)(*(DWORD *)0x147dcac + 0x84) = 2863268097; *(DWORD *)(*(DWORD *)0x147dcac + 0x9c) = 2863311361; *(DWORD *)(*(DWORD *)0x147dcac + 0xac) = 1084227584; *(DWORD *)(*(DWORD *)0x147dcac + 0x90) = bToggle ? 2863311360 : 2863311361; } current HP: *(float *)(*(DWORD *)0x123f8b8 + 0x3fc) void CGame::FreezeTime(BOOL bToggle) { *(float *)(*(DWORD *)0x14941EC + 0x1c) = bToggle ? 0 : 12; } void CGame::SetCameraMatrix(MATRIX4X4 matPos) { *(__int16 *)0x444F40 = 6379; *(__int16 *)0x004376C0 = 25323; DWORD cameraMatrix = *(DWORD *)0x14aacac + 0xb0; matPos.pad_p = 1.0f; memcpy((LPVOID)cameraMatrix, &matPos, sizeof(MATRIX4X4)); *(__int16 *)0x444F40 = 17547; *(__int16 *)0x004376C0 = -15989; } mainwnd: *(HWND *)0x120F458 is paused vel in menu: *(DWORD *)0x14d6d38 == 0x200; // Disable global suspicion Unprotect(0x11bb674, 1); *(BYTE *)0x11bb674 = 0; Unprotect(0x45DCBD, 1); *(BYTE *)0x45DCBD = 0; // Install OnDeath hook InstallJmpHook(0x5B7DEB, (DWORD)OnDeath); ... DWORD dwJmp = 0; void __declspec(naked) OnDeath() { dwJmp = 0x5B7E8A; printf(\"im in death\"); *(DWORD *)0x111c334 = 1120403456; // prevents calling this func in loop _asm { jmp dwJmp } } // fade in, last argument is float how long it will take to fade the screen DWORD dwColor = 255 | ((255 | ((255 | (255 << 8)) << 8)) << 8); ((void(__fastcall*)(DWORD, DWORD, DWORD, float))0x9bc170)(*(DWORD *)0x14A9B14, 0, dwColor, 0); // sets bird density *(BYTE *)(*(DWORD *)0x12102d0 + 0x67e4) = 254; // togle birds *(BYTE *)(*(DWORD *)0x12102d0 + 0x67e5) = bToggle ? 168 : 160; // toggle mini zep *(BYTE *)(*(DWORD *)0x143d958 + 0xec) = bToggle ? 166 : 160; // sets drunk level *(float *)(*(DWORD *)0x143d02c + 0x28) = fDrunk; // force camera behind player, 167 disables moving camera *(BYTE *)(*(DWORD *)0x1494360 + 0x10c60) = 168; // game speed *(float *)0x14e1c6c = 1000; // death state *(BYTE *)(*(DWORD *)0x123f8b8 + 0xa98) = 0; // disables falling sounds jmp at 0x54EFE1 0x9E8D20 // func which displays stats menu, has all struct offsets listed with names 0x14AADCC - struct pointer #define _pad(x,y) BYTE x[y] typedef struct _STATS { _pad(__pad0a, 0x18); // 000-024 DWORD naziWehrmachtKilled; DWORD naziKrigsmarineSquadKilled; _pad(__pad0b, 0x4); // removed ?? DWORD naziGestapoKilled; DWORD naziSSKilled; DWORD naziTerrorSquadKilled; DWORD naziDoppelziegKilled; _pad(__pad0c, 0x4); // end nazi killed stats DWORD mostNazisKilledInOneLife; _pad(__pad0d, 0x4); DWORD mostNazisKilledAtOnce; DWORD mostNazisKilledWhileDriving; DWORD mostNazisKilledBySuprise; _pad(__pad0e, 0x4); DWORD birdsKilled; DWORD civiliansKilledByPlayer; DWORD civiliansKilledByNazis; DWORD resistanceKilled; DWORD cigarettesSmoked; DWORD totalBombsPlanted; DWORD civiliansSaved; DWORD flamethrowerFuelSpent; _pad(__pad0f, 0x8); // and keeps goin } STATS; // prevents menu open 0 enables it bck *(BYTE *)0x1240545 = 1; *(BYTE *)(*(DWORD *)0x120F5C4 + 0x3fdfd) = 1; // disables load & save buttons in menu // or *(BYTE *)0x7a4346 = 0xeb; // disables for good *(__int16 *)0x5C136B = 16619; // disables quickload from button *(BYTE *)0x4365bc = 0xc3; // disables quicksave from button (disable it after character spawned, otherwise game won't get through start loading)","title":"Offsets"},{"location":"game/formats/","text":"Index","title":"Index"},{"location":"game/formats/#index","text":"","title":"Index"},{"location":"game/formats/france_fsm/","text":"France_FSM.info France_FSM.info contains entries for placements long distance visible 3D monuments to be displayed. (Game Root)\\France_FSM.info . When monument buildings are too far to render normally, they are replaced with low lod representations that can be seen from very long distances. The format contains an array of monument entries defining a CRC hash to represent the name of the 3D model to be used and 3D transform information for the position and scale of it on the map. As an example for the CRC, the entry for the Eifel tower has 0x1E821A55 , which maps to the model name: FFS_MN_A07_Eifel_Tower . Kaitai Formats PC meta: id: france_fsm file-extension: france_fsm endian: le seq: - id: file_id type: u4 - id: file_version type: u4 - id: num_sources type: u4 - id: num_objects type: u4 - id: sources type: monument_source repeat: expr repeat-expr: num_sources - id: monuments type: monument repeat: expr repeat-expr: num_objects types: monument_source: seq: - id: file_id type: u4 - id: file_version type: u4 - id: name_crc type: u4 monument: seq: - id: file_id type: u4 - id: file_version type: u4 - id: entry type: switch-on: file_version cases: 1: monument_entry_1 2: monument_entry_2 monument_entry_1: seq: - id: mesh_crc type: u4 - id: root_transform type: matrix44 monument_entry_2: seq: - id: mesh_crc type: u4 - id: min_aabb type: vector3 - id: max_aabb type: vector3 - id: root_transform type: matrix44 vector3: seq: - id: x type: f4 - id: y type: f4 - id: z type: f4 matrix44: seq: - id: m11 type: f4 - id: m12 type: f4 - id: x_scale type: f4 - id: m14 type: f4 - id: m21 type: f4 - id: m22 type: f4 - id: m23 type: f4 - id: m24 type: f4 - id: m31 type: f4 - id: m32 type: f4 - id: m33 type: f4 - id: m34 type: f4 - id: x_pos type: f4 - id: y_pos type: f4 - id: z_pos type: f4 - id: m44 type: f4","title":"France FSM"},{"location":"game/formats/france_fsm/#france_fsminfo","text":"France_FSM.info contains entries for placements long distance visible 3D monuments to be displayed. (Game Root)\\France_FSM.info . When monument buildings are too far to render normally, they are replaced with low lod representations that can be seen from very long distances. The format contains an array of monument entries defining a CRC hash to represent the name of the 3D model to be used and 3D transform information for the position and scale of it on the map. As an example for the CRC, the entry for the Eifel tower has 0x1E821A55 , which maps to the model name: FFS_MN_A07_Eifel_Tower .","title":"France_FSM.info"},{"location":"game/formats/france_fsm/#kaitai-formats","text":"","title":"Kaitai Formats"},{"location":"game/formats/france_fsm/#pc","text":"meta: id: france_fsm file-extension: france_fsm endian: le seq: - id: file_id type: u4 - id: file_version type: u4 - id: num_sources type: u4 - id: num_objects type: u4 - id: sources type: monument_source repeat: expr repeat-expr: num_sources - id: monuments type: monument repeat: expr repeat-expr: num_objects types: monument_source: seq: - id: file_id type: u4 - id: file_version type: u4 - id: name_crc type: u4 monument: seq: - id: file_id type: u4 - id: file_version type: u4 - id: entry type: switch-on: file_version cases: 1: monument_entry_1 2: monument_entry_2 monument_entry_1: seq: - id: mesh_crc type: u4 - id: root_transform type: matrix44 monument_entry_2: seq: - id: mesh_crc type: u4 - id: min_aabb type: vector3 - id: max_aabb type: vector3 - id: root_transform type: matrix44 vector3: seq: - id: x type: f4 - id: y type: f4 - id: z type: f4 matrix44: seq: - id: m11 type: f4 - id: m12 type: f4 - id: x_scale type: f4 - id: m14 type: f4 - id: m21 type: f4 - id: m22 type: f4 - id: m23 type: f4 - id: m24 type: f4 - id: m31 type: f4 - id: m32 type: f4 - id: m33 type: f4 - id: m34 type: f4 - id: x_pos type: f4 - id: y_pos type: f4 - id: z_pos type: f4 - id: m44 type: f4","title":"PC"},{"location":"game/formats/gametext/","text":"GameText.dlg GameText.dlg contains various text strings for cutscenes, help texts and etc... On the PC version, you can find this file at (Game Root)\\Cinematics\\Dialog\\(Language)\\GameText.dlg . Kaitai Formats PC meta: id: saboteur_dialog_text title: Saboteur Dialog Text File file-extension: dlg endian: le seq: - id: version type: u4 - id: base_entries type: entry_array - id: sub_entry_count type: u4 - id: sub_entry_arrays type: sub_entry repeat: expr repeat-expr: sub_entry_count - id: sub_arrays type: entry_array repeat: expr repeat-expr: sub_entry_count types: entry_array: seq: - id: entry_count type: u4 - id: total_char_count type: u4 - id: entries type: dtxt_entry repeat: expr repeat-expr: entry_count - id: end contents: \"DNEC\" dtxt_entry: seq: - id: tag contents: \"TXTD\" - id: id type: u4 - id: voice_over_key_size type: u2 - id: voice_over type: str encoding: UTF-8 size: voice_over_key_size - id: text_size type: u2 - id: text type: str encoding: UTF-16 size: text_size * 2 sub_entry: seq: - id: id type: u4 - id: offset type: u4 Xbox 360 2008 beta Note: All integers are in big endian! On the PC version they are little endian. meta: id: dlg title: Saboteur Dialog File file-extension: dlg endian: be seq: - id: header type: header - id: entries type: entry repeat: eos types: header: seq: - id: version type: u4 - id: entries_count type: u4 - id: total_char_count type: u4 entry: seq: - id: tag_type type: str encoding: ASCII size: 4 - id: body type: switch-on: tag_type cases: '\"DTXT\"': dtxt_entry dtxt_entry: seq: - id: hash size: 4 - id: key_size type: u2 - id: key type: str encoding: ASCII size: key_size - id: value_size type: u2 - id: value type: str encoding: ASCII size: value_size","title":"GameText"},{"location":"game/formats/gametext/#gametextdlg","text":"GameText.dlg contains various text strings for cutscenes, help texts and etc... On the PC version, you can find this file at (Game Root)\\Cinematics\\Dialog\\(Language)\\GameText.dlg .","title":"GameText.dlg"},{"location":"game/formats/gametext/#kaitai-formats","text":"","title":"Kaitai Formats"},{"location":"game/formats/gametext/#pc","text":"meta: id: saboteur_dialog_text title: Saboteur Dialog Text File file-extension: dlg endian: le seq: - id: version type: u4 - id: base_entries type: entry_array - id: sub_entry_count type: u4 - id: sub_entry_arrays type: sub_entry repeat: expr repeat-expr: sub_entry_count - id: sub_arrays type: entry_array repeat: expr repeat-expr: sub_entry_count types: entry_array: seq: - id: entry_count type: u4 - id: total_char_count type: u4 - id: entries type: dtxt_entry repeat: expr repeat-expr: entry_count - id: end contents: \"DNEC\" dtxt_entry: seq: - id: tag contents: \"TXTD\" - id: id type: u4 - id: voice_over_key_size type: u2 - id: voice_over type: str encoding: UTF-8 size: voice_over_key_size - id: text_size type: u2 - id: text type: str encoding: UTF-16 size: text_size * 2 sub_entry: seq: - id: id type: u4 - id: offset type: u4","title":"PC"},{"location":"game/formats/gametext/#xbox-360-2008-beta","text":"Note: All integers are in big endian! On the PC version they are little endian. meta: id: dlg title: Saboteur Dialog File file-extension: dlg endian: be seq: - id: header type: header - id: entries type: entry repeat: eos types: header: seq: - id: version type: u4 - id: entries_count type: u4 - id: total_char_count type: u4 entry: seq: - id: tag_type type: str encoding: ASCII size: 4 - id: body type: switch-on: tag_type cases: '\"DTXT\"': dtxt_entry dtxt_entry: seq: - id: hash size: 4 - id: key_size type: u2 - id: key type: str encoding: ASCII size: key_size - id: value_size type: u2 - id: value type: str encoding: ASCII size: value_size","title":"Xbox 360 2008 beta"},{"location":"game/formats/loosefiles/","text":"LooseFiles Detail The France\\looseFiles_BinPC.pack file is a very simple container of files. The idea with this could have been to bundle up a few loose files for easier reading. There are multiple loose files still in the game folder, so the reason why this file doesn't contain all of them is not known. Content Cinematics/Conversations/Conversations.cnvpack Cinematics/Cinematics.cinpack France/EditNodes/EditNodes.pack France.map France.shaders GameTemplates.wsd global.map Format Offset Size Type Name Comment 0 4 Crc Unknown Unknown Crc . 4 4 u32 Size The size of the file 8 120 string Name The nullterminated name of the file. 128 Varying byte[] Data The bytes of the file The next entry comes after the first's data array, with the same format, but the start the header is aligned to 0x10 byte boundary. This format has no specific file entry count value, fully reading must be while the input file is not over. Reading a specific file can be done with reading the header, checking for the file name, then skipping the data of the file and the byte boundary and checking the next header.","title":"LooseFiles"},{"location":"game/formats/loosefiles/#loosefiles","text":"","title":"LooseFiles"},{"location":"game/formats/loosefiles/#detail","text":"The France\\looseFiles_BinPC.pack file is a very simple container of files. The idea with this could have been to bundle up a few loose files for easier reading. There are multiple loose files still in the game folder, so the reason why this file doesn't contain all of them is not known.","title":"Detail"},{"location":"game/formats/loosefiles/#content","text":"Cinematics/Conversations/Conversations.cnvpack Cinematics/Cinematics.cinpack France/EditNodes/EditNodes.pack France.map France.shaders GameTemplates.wsd global.map","title":"Content"},{"location":"game/formats/loosefiles/#format","text":"Offset Size Type Name Comment 0 4 Crc Unknown Unknown Crc . 4 4 u32 Size The size of the file 8 120 string Name The nullterminated name of the file. 128 Varying byte[] Data The bytes of the file The next entry comes after the first's data array, with the same format, but the start the header is aligned to 0x10 byte boundary. This format has no specific file entry count value, fully reading must be while the input file is not over. Reading a specific file can be done with reading the header, checking for the file name, then skipping the data of the file and the byte boundary and checking the next header.","title":"Format"},{"location":"game/formats/megapack/","text":"Megapack / Kilopack Detail The megapack file is just an archive file for storing different kind of assets. A megapack (or kilopack) stores pack files inside them. Different megapacks store different kind and amount of data. The data stored in megapacks can be: Models Meshes Physics data Textures TODO: more The megapack file format is a simple one: all the pack files are packed together inside a big file with a header specifying (for each file) the name, where they start and how big they are. Formats Entry Header Offset Size Type Name Description 0 4 Crc Id File name's Crc 4 4 Crc Path File path's Crc 8 4 u32 Size File size 12 8 u64 Offset File offset inside the megapack File Offset Size Type Name Description 0 4 FourCC Magic The file's magic number \"MP00\" 4 4 u32 File count The number of embedded pack files 8 20 Entry header [] File entries The header entries for the pack files 8 + 20*Count 8 [ Crc , Crc ] Unk ids Unknown array containing Crc pairs 8 + 28*Count Varying byte[] File data Offset is padded to 0x800 byte boundary Kaitai structure definition: meta: id: megapack file-extension: - megapack - kilopack endian: le seq: - id: magic contents: \"00PM\" - id: file_entry_count type: u4 - id: file_entries type: file_entry repeat: expr repeat-expr: file_entry_count - id: crc_pairs type: crc_pair repeat: expr repeat-expr: file_entry_count types: file_entry: seq: - id: crc type: u4 - id: unk_crc type: u4 - id: size type: u4 - id: offset type: u8 instances: data: pos: offset size: size crc_pair: seq: - id: crc1 type: u4 - id: crc2 type: u4","title":"Megapack/Kilopack"},{"location":"game/formats/megapack/#megapack-kilopack","text":"","title":"Megapack / Kilopack"},{"location":"game/formats/megapack/#detail","text":"The megapack file is just an archive file for storing different kind of assets. A megapack (or kilopack) stores pack files inside them. Different megapacks store different kind and amount of data. The data stored in megapacks can be: Models Meshes Physics data Textures TODO: more The megapack file format is a simple one: all the pack files are packed together inside a big file with a header specifying (for each file) the name, where they start and how big they are.","title":"Detail"},{"location":"game/formats/megapack/#formats","text":"","title":"Formats"},{"location":"game/formats/megapack/#entry-header","text":"Offset Size Type Name Description 0 4 Crc Id File name's Crc 4 4 Crc Path File path's Crc 8 4 u32 Size File size 12 8 u64 Offset File offset inside the megapack","title":"Entry Header"},{"location":"game/formats/megapack/#file","text":"Offset Size Type Name Description 0 4 FourCC Magic The file's magic number \"MP00\" 4 4 u32 File count The number of embedded pack files 8 20 Entry header [] File entries The header entries for the pack files 8 + 20*Count 8 [ Crc , Crc ] Unk ids Unknown array containing Crc pairs 8 + 28*Count Varying byte[] File data Offset is padded to 0x800 byte boundary Kaitai structure definition: meta: id: megapack file-extension: - megapack - kilopack endian: le seq: - id: magic contents: \"00PM\" - id: file_entry_count type: u4 - id: file_entries type: file_entry repeat: expr repeat-expr: file_entry_count - id: crc_pairs type: crc_pair repeat: expr repeat-expr: file_entry_count types: file_entry: seq: - id: crc type: u4 - id: unk_crc type: u4 - id: size type: u4 - id: offset type: u8 instances: data: pos: offset size: size crc_pair: seq: - id: crc1 type: u4 - id: crc2 type: u4","title":"File"},{"location":"game/formats/pack/","text":"","title":"Pack"},{"location":"game/lua/","text":"Lua The Saboteur contains Lua 5.1 scripting language, which was used for controlling flow of missions, controlling and spawning of peds, and various other parts of the game. On the PC version, Lua seems to not be modified on PC platform, but there seems to be changes on Xbox platform. Hooking For getting LuaManager class which manages the global Lua machine is following offset: uintptr_t luamanager_ptr = *(uintptr_t*)0x0142D324; TODO: Following statement needs to be verified For getting LuaMachine class, which contains Lua state is following offset of LuaManager: uintptr_t luamachine_ptr = luamanager_ptr + 0x124; For getting lua_State pointer, following code is used: uintptr_t lua_state = *((uintptr_t*)*(uintptr_t*)luamachine_ptr); Executing Lua Commands For executing Lua commands, we need to know location of two functions, lua_pcall and luaL_loadstring . There are offsets of following functions: uintptr_t luaL_loadstring_ptr = 0x4041B0; uintptr_t lua_pcall = 0x401F90; Afterwards, we can execute Lua command as following: __asm { push command ; pointer to char* of your Lua command push lua_state call luaL_loadstring_ptr add esp, 0x8 push 0 push 0 push 0 push lua_state call lua_pcall add esp, 0x10 } Enabling Lua's print function In release version of The Saboteur, the game is deleting print function in Lua machine. You can avoid this by nopping instruction located at 0x006FAB6B (nop 5 bytes)","title":"Lua"},{"location":"game/lua/#lua","text":"The Saboteur contains Lua 5.1 scripting language, which was used for controlling flow of missions, controlling and spawning of peds, and various other parts of the game. On the PC version, Lua seems to not be modified on PC platform, but there seems to be changes on Xbox platform.","title":"Lua"},{"location":"game/lua/#hooking","text":"For getting LuaManager class which manages the global Lua machine is following offset: uintptr_t luamanager_ptr = *(uintptr_t*)0x0142D324; TODO: Following statement needs to be verified For getting LuaMachine class, which contains Lua state is following offset of LuaManager: uintptr_t luamachine_ptr = luamanager_ptr + 0x124; For getting lua_State pointer, following code is used: uintptr_t lua_state = *((uintptr_t*)*(uintptr_t*)luamachine_ptr);","title":"Hooking"},{"location":"game/lua/#executing-lua-commands","text":"For executing Lua commands, we need to know location of two functions, lua_pcall and luaL_loadstring . There are offsets of following functions: uintptr_t luaL_loadstring_ptr = 0x4041B0; uintptr_t lua_pcall = 0x401F90; Afterwards, we can execute Lua command as following: __asm { push command ; pointer to char* of your Lua command push lua_state call luaL_loadstring_ptr add esp, 0x8 push 0 push 0 push 0 push lua_state call lua_pcall add esp, 0x10 }","title":"Executing Lua Commands"},{"location":"game/lua/#enabling-luas-print-function","text":"In release version of The Saboteur, the game is deleting print function in Lua machine. You can avoid this by nopping instruction located at 0x006FAB6B (nop 5 bytes)","title":"Enabling Lua's print function"},{"location":"tools/","text":"Tools SabTool","title":"Index"},{"location":"tools/#tools","text":"","title":"Tools"},{"location":"tools/#sabtool","text":"","title":"SabTool"},{"location":"tools/sabtool/","text":"SabTool GitHub link A CLI tool for manipulating game content, mostly reading and extracting currently.","title":"SabTool"},{"location":"tools/sabtool/#sabtool","text":"GitHub link A CLI tool for manipulating game content, mostly reading and extracting currently.","title":"SabTool"}]}